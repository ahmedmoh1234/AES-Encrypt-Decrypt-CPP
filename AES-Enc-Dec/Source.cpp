#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <map>

using namespace std;
using Word = vector<unsigned char>;


template <class T>
ostream& operator<<(ostream& os, const vector<T>& vec)
{
	for (size_t i = 0; i < vec.size(); i++)
	{
		os << hex << static_cast<int>(vec[i]) << " ";
	}
	os << "\n";

	return os;
}

Word operator^ (const Word& w1, const Word& w2)
{
	Word temp;
	if (w1.size() != w2.size())
		return temp;
	for (size_t i = 0; i < w1.size(); i++)
	{
		//cout << "w1 = " << static_cast<int>(w1[i]) << " w2 = " << static_cast<int>(w2[i]) << "\n";
		temp.push_back(w1[i] ^ w2[i]);
	}
	return temp;
}

const int BUFF_SIZE = 16;
const int NB = 4;
int NR;
int NK;		//no. of columns of the key. The column consists of 4 bytes

const map<unsigned char, unsigned char> subBytes{
	{0x0,0x63}	,{0x1, 0x7c}	,{0x2, 0x77},{0x3, 0x7b},{0x4, 0xf2},{0x5, 0x6b},{0x6, 0x6f},{0x7, 0xc5},
	{0x8, 0x30}	,{0x9, 0x01}	,{0xa, 0x67},{0xb, 0x2b},{0xc, 0xfe},{0xd, 0xd7},{0xe, 0xab},{0xf, 0x76},
	{0x10, 0xca},{0x11, 0x82}	,{0x12, 0xc9},{0x13, 0x7d},{0x14, 0xfa},{0x15, 0x59},{0x16, 0x47},{0x17, 0xf0},
	{0x18, 0xad},{0x19, 0xd4}	,{0x1a, 0xa2},{0x1b, 0xaf},{0x1c, 0x9c},{0x1d, 0xa4},{0x1e, 0x72},{0x1f, 0xc0},
	{0x20, 0xb7},{0x21, 0xfd}	,{0x22, 0x93},{0x23, 0x26},{0x24, 0x36},{0x25, 0x3f},{0x26, 0xf7},{0x27, 0xcc},
	{0x28, 0x34},{0x29, 0xa5}	,{0x2a, 0xe5},{0x2b, 0xf1},{0x2c, 0x71},{0x2d, 0xd8},{0x2e, 0x31},{0x2f, 0x15},
	{0x30, 0x04},{0x31, 0xc7}	,{0x32, 0x23},{0x33, 0xc3},{0x34, 0x18},{0x35, 0x96},{0x36, 0x05},{0x37, 0x9a},
	{0x38, 0x07},{0x39, 0x12}	,{0x3a, 0x80},{0x3b, 0xe2},{0x3c, 0xeb},{0x3d, 0x27},{0x3e, 0xb2},{0x3f, 0x75},
	{0x40, 0x09},{0x41, 0x83}	,{0x42, 0x2c},{0x43, 0x1a},{0x44, 0x1b},{0x45, 0x6e},{0x46, 0x5a},{0x47, 0xa0},
	{0x48, 0x52},{0x49, 0x3b}	,{0x4a, 0xd6},{0x4b, 0xb3},{0x4c, 0x29},{0x4d, 0xe3},{0x4e, 0x2f},{0x4f, 0x84},
	{0x50, 0x53},{0x51, 0xd1}	,{0x52, 0x00},{0x53, 0xed},{0x54, 0x20},{0x55, 0xfc},{0x56, 0xb1},{0x57, 0x5b},
	{0x58, 0x6a},{0x59, 0xcb}	,{0x5a, 0xbe},{0x5b, 0x39},{0x5c, 0x4a},{0x5d, 0x4c},{0x5e, 0x58},{0x5f, 0xcf},
	{0x60, 0xd0},{0x61, 0xef}	,{0x62, 0xaa},{0x63, 0xfb},{0x64, 0x43},{0x65, 0x4d},{0x66, 0x33},{0x67, 0x85},
	{0x68, 0x45},{0x69, 0xf9}	,{0x6a, 0x02},{0x6b, 0x7f},{0x6c, 0x50},{0x6d, 0x3c},{0x6e, 0x9f},{0x6f, 0xa8},
	{0x70, 0x51},{0x71, 0xa3}	,{0x72, 0x40},{0x73, 0x8f},{0x74, 0x92},{0x75, 0x9d},{0x76, 0x38},{0x77, 0xf5},
	{0x78, 0xbc},{0x79, 0xb6}	,{0x7a, 0xda},{0x7b, 0x21},{0x7c, 0x10},{0x7d, 0xff},{0x7e, 0xf3},{0x7f, 0xd2},
	{0x80, 0xcd},{0x81, 0x0c}	,{0x82, 0x13},{0x83, 0xec},{0x84, 0x5f},{0x85, 0x97},{0x86, 0x44},{0x87, 0x17},
	{0x88, 0xc4},{0x89, 0xa7}	,{0x8a, 0x7e},{0x8b, 0x3d},{0x8c, 0x64},{0x8d, 0x5d},{0x8e, 0x19},{0x8f, 0x73},
	{0x90, 0x60},{0x91, 0x81}	,{0x92, 0x4f},{0x93, 0xdc},{0x94, 0x22},{0x95, 0x2a},{0x96, 0x90},{0x97, 0x88},
	{0x98, 0x46},{0x99, 0xee}	,{0x9a, 0xb8},{0x9b, 0x14},{0x9c, 0xde},{0x9d, 0x5e},{0x9e, 0x0b},{0x9f, 0xdb},
	{0xa0, 0xe0},{0xa1, 0x32}	,{0xa2, 0x3a},{0xa3, 0x0a},{0xa4, 0x49},{0xa5, 0x06},{0xa6, 0x24},{0xa7, 0x5c},
	{0xa8, 0xc2},{0xa9, 0xd3}	,{0xaa, 0xac},{0xab, 0x62},{0xac, 0x91},{0xad, 0x95},{0xae, 0xe4},{0xaf, 0x79},
	{0xb0, 0xe7},{0xb1, 0xc8}	,{0xb2, 0x37},{0xb3, 0x6d},{0xb4, 0x8d},{0xb5, 0xd5},{0xb6, 0x4e},{0xb7, 0xa9},
	{0xb8, 0x6c},{0xb9, 0x56}	,{0xba, 0xf4},{0xbb, 0xea},{0xbc, 0x65},{0xbd, 0x7a},{0xbe, 0xae},{0xbf, 0x08},
	{0xc0, 0xba},{0xc1, 0x78}	,{0xc2, 0x25},{0xc3, 0x2e},{0xc4, 0x1c},{0xc5, 0xa6},{0xc6, 0xb4},{0xc7, 0xc6},
	{0xc8, 0xe8},{0xc9, 0xdd}	,{0xca, 0x74},{0xcb, 0x1f},{0xcc, 0x4b},{0xcd, 0xbd},{0xce, 0x8b},{0xcf, 0x8a},
	{0xd0, 0x70},{0xd1, 0x3e}	,{0xd2, 0xb5},{0xd3, 0x66},{0xd4, 0x48},{0xd5, 0x03},{0xd6, 0xf6},{0xd7, 0x0e},
	{0xd8, 0x61},{0xd9, 0x35}	,{0xda, 0x57},{0xdb, 0xb9},{0xdc, 0x86},{0xdd, 0xc1},{0xde, 0x1d},{0xdf, 0x9e},
	{0xe0, 0xe1},{0xe1, 0xf8}	,{0xe2, 0x98},{0xe3, 0x11},{0xe4, 0x69},{0xe5, 0xd9},{0xe6, 0x8e},{0xe7, 0x94},
	{0xe8, 0x9b},{0xe9, 0x1e}	,{0xea, 0x87},{0xeb, 0xe9},{0xec, 0xce},{0xed, 0x55},{0xee, 0x28},{0xef, 0xdf},
	{0xf0, 0x8c},{0xf1, 0xa1}	,{0xf2, 0x89},{0xf3, 0x0d},{0xf4, 0xbf},{0xf5, 0xe6},{0xf6, 0x42},{0xf7, 0x68},
	{0xf8, 0x41},{0xf9, 0x99}	,{0xfa, 0x2d},{0xfb, 0x0f},{0xfc, 0xb0},{0xfd, 0x54},{0xfe, 0xbb},{0xff, 0x16}
};

//The first entry in the Rcon array is useless since the indexing of rcon starts at 1 not 0
const unsigned char Rcon [] = {0x01, 0x01,0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36};

inline string readFileName();

inline void encryption();
inline void decryption();

inline void cipherRound();
inline vector<Word> keyExpansion(vector<unsigned char> key);
inline void rotateWord(Word& word);
inline void subWord(Word& word);
inline void shiftRows(vector<Word>& words);

//What will happen if the file size is smaller than 128 bits ??
//Padding will be used

int main()
{
	//Ask the user whether they want to encrypt or decrypt

	Word key{0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4};
	keyExpansion(key);

	int encDecChoice;
	cout << "Enter 1 to encrypt\n";
	cout << "Enter 2 to decrypt\n";
	cin >> encDecChoice;

	while (encDecChoice != 1 && encDecChoice != 2)
	{
		cout << "Wrong choice please enter a correct choice\n";
		cin >> encDecChoice;
	}

	if (encDecChoice == 1)
	{
		encryption();
	}
	else
	{
		decryption();
	}

	return 0;
}

inline string readFileName()
{
	string fileNameTemp;
	cout << "Please input filename/path : ";
	cin >> fileNameTemp;
	cout << "\n";

	if (fileNameTemp[0] == '"')
		fileNameTemp.erase(0, 1);
	if (fileNameTemp[fileNameTemp.size() - 1] == '"')
		fileNameTemp.erase(fileNameTemp.size() - 1, 1);


	return std::move(fileNameTemp);

}

inline void encryption()
{
	//Ask the user whether to generate a random key or to enter a key

	//The choice of the user
	int keyChoice;

	//The key that will be used in encryption
	vector<unsigned char> key;
	cout << "Enter 1 to generate a key randomly\n";
	cout << "Enter 2 to enter a key manually\n";
	cin >> keyChoice;

	while (keyChoice != 1 && keyChoice != 2)
	{
		cout << "Wrong choice please enter a correct choice\n";
		cin >> keyChoice;
	}

	if (keyChoice == 1)
	{
		//Random key
		//Random key will have 3 options
		//1- 128-bit key
		//2- 192-bit key
		//3- 256-bit key

	}
	else
	{
		//Key entered manually
		//Ask the user to enter the size of the key
		//128 bits -> 16 characters
		//192 bits -> 24 characters
		//256 bits -> 32 characters

		//I did not use a hash function because I want to implement the standart algorithm so any AES decryptor can decrypt it.
	}



	//Reading 128 bits from file
	char buff[BUFF_SIZE];


	string fileName = readFileName();


	ifstream inputFile(fileName, ios::binary);

	while (!inputFile.is_open())
	{
		cout << "Could not open file. ";
		fileName = readFileName();

		inputFile.open(fileName, ios::binary);
	}
	cout << "File opened successfully\n";



	if (!inputFile.read(buff, BUFF_SIZE))
	{
		//There was an error reading 16 bytes

		//check the number of bytes actually read
		int readBytesCount = inputFile.gcount();
		for (int i = 0; i < readBytesCount; i++)
		{
			cout << buff[i] << " ";
		}

		//Padding is required
	}
	else
	{
		//16 bytes were read no problem
		for (int i = 0; i < BUFF_SIZE; i++)
		{
			cout << buff[i] << " ";
		}
	}
}

inline void decryption()
{
}

inline void cipherRound()
{

}

inline vector<Word> keyExpansion(vector<unsigned char> key)
{
	//cout << "Entered keyExpansion\n";
	//w: key schedule
	//the first 4 words of the key schedule is the the first 4 words of the key
	//for 16 byte key, afterwards, w[i] = w[i-1] ^ w[i-4]
	//if i is a multiple of 4, w[i] = g(w[i-1]) ^ w[i-4]
	//function g() is composed of 3 steps
	//1- rotate left (e.g. b0,b1,b2,b3 --> b1,b2,b3,b0)
	//2- perform SubByte on each byte
	//3- XOR with Rcon[j]

	vector<Word> w;
	int keySize = key.size();
	NK = keySize / 4;

	cout << "NK = " << NK << "\n";
	if (keySize == 16)
	{
		NR = 10;
	}
	else if (keySize == 24)
	{
		NR = 12;
	}
	else if (keySize == 32)
	{
		NR = 14;
	}
	else
	{
		cout << "Error. Wrong key size\n";
	}

	w.resize(NB * (NR + 1));

	for (size_t i = 0; i < NK; i++)
	{
		//take 4 bytes and make a word
		w[i] = { key[4*i] , key[4*i+1], key[4*i+2], key[4*i+3]};
	}

	for (size_t i = NK; i < NB*(NR+1); i++)
	{
		Word temp = w[i - 1];

		//cout << "temp = " << temp ;
		

		if (i % NK == 0)
		{
			//1- rotate left (e.g. b0,b1,b2,b3 --> b1,b2,b3,b0)
			rotateWord(temp);
			//cout << "After RotWord = " << temp;
			//2- perform SubByte on each byte
			subWord(temp);
			//cout << "After subWord = " << temp;
			//3- XOR with Rcon[j]
			//cout << " i / NK = " << i / NK << "\n";
			temp = temp ^ Word{ Rcon[i / NK], 0x0,0x0,0x0 };
			//cout << "After Rcon XOR = " << temp;


		}
		else if (NK > 6 && (i % NK == 4))
			//Special case for NK = 8
			// if NK == 8 && i-4 is a multiple of NK
		{
			subWord(temp);
		}

		w[i] = w[i - NK] ^ temp;

		if (w[i].size() == 0)
		{
			cout << "Error. XOR operands have unequal sizes\n";
		}

		//TESTING
		//cout << "w[" << i << "] = " << hex << w[i] << "\n";
	}

	return w;
}

inline void rotateWord(Word& word) // TESTED
{

	unsigned char temp = word[0];
	word.erase(word.begin());
	word.push_back(temp);
	

}

inline void subWord(Word& word) //TESTED
{
	for (int i = 0; i < word.size(); i++)
	{
		//cout << "Replacing " << hex << static_cast<int>(word[i]) << " with " << hex << static_cast<int>(subBytes.at(word[i])) << "\n";;
		word[i] = subBytes.at(word[i]);
	}
}

inline void shiftRows( vector<Word>& words)		//TESTED
{
	for (size_t i = 1; i < 4; i++)
	{
		for (size_t j = 0; j < i; j++)
		{
			unsigned char temp = words[i][0];
			words[i].erase(words[i].begin());
			words[i].push_back(temp);
		}
	}
}